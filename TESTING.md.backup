# BaseField Testing Documentation

This document describes the comprehensive test suite for the `BaseField` class, developed using Test-Driven Development (TDD) methodology.

## Overview

The BaseField test suite focuses on thorough testing of the core field functionality in the CRUD package. Using a TDD approach, we've built a robust test suite that covers:

- **209 tests** with **422 assertions**
- **Step-by-step testing** for complex methods
- **Method extraction** for better maintainability
- **Comprehensive coverage** of all BaseField functionality

## Test Structure

### Core Test Files

```
tests/Unit/Fields/BaseField/
├── BaseFieldTest.php              # Main field functionality tests
├── FieldDataAndFilterTest.php     # Data and filter method tests
├── FieldFillValueStep1Test.php    # Raw value extraction tests
├── FieldFillValueStep2Test.php    # Relation handling tests
└── FieldFillValueStep3Test.php    # Accessor callback tests
```

### Test Categories

#### BaseFieldTest.php (41 tests)
- Basic field instantiation and configuration
- Method chaining and fluent API
- Property setters (page, display, class, etc.)
- Core functionality validation

#### FieldDataAndFilterTest.php (27 tests)
- Data management and validation
- Filter configuration and behavior
- Dataset population
- Method chaining with data operations

#### Step-by-Step fillValue() Testing (101 tests)
- **Step 1**: Raw value extraction (18 tests)
- **Step 2**: Relation processing (6 tests)
- **Step 3**: Accessor callbacks (8 tests)

## TDD Approach

### Step-by-Step Testing Methodology

We use a systematic approach to test complex methods by breaking them down into testable steps:

1. **Extract Logic**: Refactor complex methods into smaller, testable functions
2. **Step-by-Step Tests**: Create dedicated test files for each step
3. **Integration**: Ensure all steps work together correctly
4. **Cleanup**: Remove redundant tests after refactoring

### Example: fillValue() Method Refactoring

**Original Complex Method:**
```php
protected function fillValue($model): void
{
    if (isset($model)) {
        // Complex logic here...
    }
}
```

**Refactored into Testable Steps:**
```php
protected function fillValue($model): void
{
    if (isset($model)) {
        $this->extractRawValue($model);
        $this->extractRelationalValue($model);
        $this->applyAccessor($model);
    }
}
```

**Dedicated Test Files:**
- `FieldFillValueStep1Test.php` - Tests `extractRawValue()`
- `FieldFillValueStep2Test.php` - Tests `extractRelationalValue()`
- `FieldFillValueStep3Test.php` - Tests `applyAccessor()`

## Running Tests

### Docker Test Runner (Recommended)

```bash
# Run all BaseField tests
./test-docker.sh test -- --filter "*BaseField*"

# Run specific test files
./test-docker.sh test -- --filter BaseFieldTest
./test-docker.sh test -- --filter FieldDataAndFilterTest

# Run step-by-step tests
./test-docker.sh test -- --filter "*FillValue*"

# Run specific test methods
./test-docker.sh test -- --filter test_filter_method_supports_chaining
./test-docker.sh test -- --filter test_data_method_with_array
```

### PHPUnit Direct

```bash
# Run all tests
./vendor/bin/phpunit

# Run specific test class
./vendor/bin/phpunit --filter BaseFieldTest

# Run with coverage
./vendor/bin/phpunit --coverage-html coverage/html
```

## Test Coverage

### ✅ Fully Tested Methods

#### Core Functionality
- `make()` - Field instantiation
- `display()` - Label setting
- `page()` - Page configuration
- `class()` - CSS class management
- `get()` - Field data retrieval

#### Data Management
- `data()` - Data array/object handling
- `options()` - Select options management
- `filter()` - Filter configuration
- `filterType()` - Filter type setting

#### Value Processing (fillValue)
- `extractRawValue()` - Raw model value extraction
- `extractRelationalValue()` - Relation-based value handling
- `applyAccessor()` - Custom accessor callbacks

#### Method Chaining
- Fluent API support across all setter methods
- Return `$this` validation
- Chain validation in dedicated tests

### Test Patterns Used

#### Mock Classes
```php
class MockEloquentModel implements ArrayAccess
{
    private array $data = [];

    public function __construct(array $data = [])
    {
        $this->data = $data;
    }

    public function offsetExists($offset): bool
    {
        return isset($this->data[$offset]);
    }

    public function offsetGet($offset)
    {
        return $this->data[$offset] ?? null;
    }

    // ... other ArrayAccess methods
}
```

#### Assertion Patterns
```php
// Property validation
$this->assertEquals('email', $this->getPropertyValue($field, 'name'));

// Method chaining
$result = $field->filter()->display('Label');
$this->assertSame($field, $result);

// Array data validation
$this->assertCount(3, $this->getPropertyValue($field, 'data'));
$this->assertEquals('Active', $dataSet['active']);
```

## Code Quality Improvements

### Method Extraction Benefits

1. **Testability**: Complex methods broken into focused, testable units
2. **Maintainability**: Smaller methods are easier to understand and modify
3. **Reusability**: Extracted methods can be used independently
4. **Debugging**: Easier to isolate issues to specific functionality

### Test Organization

1. **Logical Grouping**: Related tests grouped in dedicated files
2. **Clear Naming**: Test methods clearly describe what they validate
3. **Step-by-Step Coverage**: Complex logic tested incrementally
4. **Cleanup Strategy**: Redundant tests removed after refactoring

## Performance Metrics

- **Execution Time**: ~4.4 seconds for full suite
- **Memory Usage**: ~40MB peak
- **Test Isolation**: Each test runs in clean environment
- **Docker Optimization**: Pre-built images for fast startup

## Development Workflow

### Adding New Tests

1. **Identify Functionality**: Determine what needs testing
2. **Write Failing Test**: Create test that exposes missing functionality
3. **Implement Code**: Write minimal code to pass the test
4. **Refactor**: Improve code structure while maintaining tests
5. **Verify Coverage**: Ensure all edge cases are covered

### Example: Adding Filter Method Test

```php
// 1. Write failing test
public function test_filter_method_sets_filterable_when_no_arguments_and_no_data()
{
    $field = Select::make('status');
    $result = $field->filter();
    $this->assertTrue($this->getPropertyValue($field, 'filterable'));
    $this->assertSame($field, $result); // Method chaining
}

// 2. Implement minimal code
public function filter(...$items): static
{
    $this->filterable = true;
    // ... implementation
    return $this;
}

// 3. Add comprehensive tests
public function test_filter_method_supports_chaining()
{
    $field = Select::make('status')
        ->filter()
        ->display('Status')
        ->class('form-control');
    // ... assertions
}
```

## Continuous Integration

```yaml
# .github/workflows/test.yml
name: BaseField Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: ./test-docker.sh test -- --filter "*BaseField*"
      - run: ./test-docker.sh test -- --coverage-clover=coverage.xml
```

## Future Enhancements

### Planned Test Improvements
- Integration tests combining all fillValue() steps
- Performance testing for large datasets
- Edge case testing for complex relations
- Accessibility testing for field rendering

### Test Maintenance
- Regular review of test coverage
- Update tests when BaseField API changes
- Performance monitoring and optimization
- Documentation updates with new features

This test suite serves as a comprehensive example of TDD applied to complex business logic, demonstrating systematic testing approaches that ensure code reliability and maintainability.

## Quick Start

The easiest way to run tests is using the Docker test runner:

```bash
# Run all tests with code coverage
./test-docker.sh

# Run all tests (same as above)
./test-docker.sh test

# Run specific test class
./test-docker.sh test -- --filter BaseFieldTest

# Run specific test method
./test-docker.sh test -- --filter test_filter_method_supports_chaining

# Interactive debugging shell
./test-docker.sh interactive

# Clean up Docker resources
./test-docker.sh clean
```

## Test Results

The test suite includes:
- **209 tests** with **422 assertions**
- **18.42% line coverage** (344/1868 lines)
- **10.91% method coverage** (37/339 methods)
- Execution time: ~4.4 seconds

## Test Structure

### Unit Tests (`tests/Unit/`)
- **Controllers/**: Tests for CRUD controller traits
- **Services/**: Tests for DataService, StoreService, UpdateService
- **Fields/**: Tests for field system components
- **Scaffold/**: Tests for scaffolding system

### Integration Tests (`tests/Integration/`)
- **ControllerMethodExecutionTest.php**: Tests controller method execution
- **ServiceExecutionTest.php**: Tests service layer business logic
- **FieldComprehensiveTest.php**: Tests field system functionality
- **HookSystemTest.php**: Tests hook system integration
- **ScaffolderEdgeCasesTest.php**: Tests edge cases and error handling

### Feature Tests (`tests/Feature/`)
- **CrudEndpointsTest.php**: Tests HTTP endpoints functionality

## Coverage Reports

After running tests, coverage reports are generated:
- **HTML Report**: `coverage/html/index.html`
- **XML Report**: `coverage/clover.xml`
- **Text Report**: `coverage.txt`

## Docker Setup

The testing uses an optimized Docker setup:
- **`test-docker.sh`**: Main test runner script with argument support
- **`docker-compose.test.yml`**: Docker Compose configuration
- **`Dockerfile.test`**: Optimized test image with pre-installed dependencies
- **Performance**: Sub-5-second test execution with code coverage
- **Filtering**: Support for all PHPUnit arguments (`--filter`, `--group`, `--verbose`, etc.)

### Docker Test Runner Features

- **Argument Passing**: Supports all PHPUnit command-line options
- **Fast Execution**: Pre-built images with cached dependencies
- **Coverage Reports**: Automatic HTML and XML coverage generation
- **Interactive Mode**: Debug shell for troubleshooting
- **Resource Cleanup**: Easy cleanup of Docker containers and volumes

### Feature Tests (`tests/Feature/`)
- **CrudEndpointsTest.php**: End-to-end tests for all CRUD HTTP endpoints

### Test Models (`tests/Models/`)
- **TestModel.php**: Simple model for testing CRUD operations
- **TestCategory.php**: Additional model for relationship testing

### Test Controllers (`tests/Controllers/`)
- **TestController.php**: Test controller that uses the CRUD trait

### Test Scaffolders (`tests/Scaffolders/`)
- **TestScaffolder.php**: Scaffolder for test models

## Test Coverage

The test suite covers:

### ✅ Core Functionality
- **Model Operations**: Create, read, update, delete with database persistence
- **Soft Delete System**: Soft deletion, restoration, and force deletion
- **Class Structure**: CRUD trait composition and controller functionality
- **Scaffolder Integration**: Model binding and field configuration

### ✅ Database Operations
- **CRUD Operations**: Full create, read, update, delete cycle
- **Soft Delete Lifecycle**: Delete → Restore → Force Delete
- **Data Integrity**: Database constraints and relationships
- **Migration Support**: Automated table creation for testing

### ✅ Package Components
- **Trait System**: Verification of all CRUD trait functionality  
- **Hook Architecture**: Hook trait existence and registration methods
- **Service Classes**: DataService and other core services
- **Model Integration**: Eloquent model compatibility

### ✅ Integration Testing
- **Database Persistence**: Real database operations with SQLite
- **Model Relationships**: Testing model associations and queries
- **Scaffolder Configuration**: Field definitions and validation rules
- **Package Loading**: Service provider and autoloading verification

## Running Specific Tests

### Using Docker Test Runner (Recommended)

```bash
# Run all tests with code coverage
./test-docker.sh test

# Run specific test class
./test-docker.sh test -- --filter BaseFieldTest
./test-docker.sh test -- --filter FieldDataAndFilterTest

# Run specific test method
./test-docker.sh test -- --filter test_filter_method_supports_chaining
./test-docker.sh test -- --filter BaseFieldTest::test_field_page_method_sets_page_property

# Run tests by pattern
./test-docker.sh test -- --filter "*filter*"
./test-docker.sh test -- --filter "*data*"

# Run tests with specific group
./test-docker.sh test -- --group integration
./test-docker.sh test -- --exclude-group slow

# Run tests with verbose output
./test-docker.sh test -- --verbose

# Run tests without coverage (faster)
./test-docker.sh test -- --no-coverage
```

### Using PHPUnit Directly

```bash
# Run all tests
./vendor/bin/phpunit

# Run only Unit tests
./vendor/bin/phpunit tests/Unit

# Run only Feature tests
./vendor/bin/phpunit tests/Feature

# Run specific test class
./vendor/bin/phpunit tests/Unit/Fields/BaseField/BaseFieldTest.php

# Run specific test method
./vendor/bin/phpunit --filter test_store_endpoint_creates_new_record

# Run tests by pattern
./vendor/bin/phpunit --filter "*BaseField*"

# Run tests with coverage
./vendor/bin/phpunit --coverage-html coverage/html

# Run tests with specific configuration
./vendor/bin/phpunit --configuration phpunit.xml --testsuite Unit
```

### Common Test Filtering Examples

```bash
# Test specific functionality
./test-docker.sh test -- --filter "*filter*"
./test-docker.sh test -- --filter "*data*"
./test-docker.sh test -- --filter "*field*"

# Test specific classes
./test-docker.sh test -- --filter BaseFieldTest
./test-docker.sh test -- --filter FieldDataAndFilterTest
./test-docker.sh test -- --filter CrudControllerTest

# Test specific methods
./test-docker.sh test -- --filter test_filter_method_sets_filterable_when_no_arguments_and_no_data
./test-docker.sh test -- --filter test_data_method_with_array

# Test by category
./test-docker.sh test -- --filter "*Test" --exclude-group integration
./test-docker.sh test -- --group unit
```

## Test Configuration

The test suite uses:
- **SQLite in-memory database** for fast, isolated testing
- **Orchestra Testbench** for Laravel package testing environment
- **PHPUnit 10** as the testing framework
- **Database migrations** automatically created for each test
- **Simplified approach** focusing on core functionality verification

## Writing New Tests

### For new CRUD operations:
1. Add unit tests to verify the method exists and works
2. Add feature tests to verify HTTP endpoints work
3. Add database assertions to verify data changes

### For new hook functionality:
1. Add tests to `HooksTest.php` to verify hook methods exist
2. Add integration tests to verify hooks are called correctly

### Example test for new functionality:
```php
public function test_new_crud_method()
{
    // Arrange: Set up test data
    $model = TestModel::create(['name' => 'Test']);
    
    // Act: Call your method
    $response = $this->post("/test/{$model->id}/new-action");
    
    // Assert: Verify results
    $response->assertStatus(200);
    $this->assertDatabaseHas('test_models', [
        'id' => $model->id,
        'expected_field' => 'expected_value'
    ]);
}
```

## Continuous Integration

To integrate with CI/CD:

```yaml
# .github/workflows/test.yml (for GitHub Actions)
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: shivammathur/setup-php@v2
        with:
          php-version: 8.1
      - run: composer install --dev
      - run: ./test-docker.sh test  # Run all tests
      - run: ./test-docker.sh test -- --filter "*integration*"  # Run integration tests only
      - run: ./test-docker.sh test -- --coverage-clover=coverage.xml  # Generate coverage for CI
```

### CI Optimization Tips

```bash
# Run fast unit tests first
./test-docker.sh test -- --testsuite Unit --no-coverage

# Run integration tests separately
./test-docker.sh test -- --group integration

# Generate coverage only on main branch
if [ "$GITHUB_REF" = "refs/heads/main" ]; then
  ./test-docker.sh test -- --coverage-clover=coverage.xml
fi
```
